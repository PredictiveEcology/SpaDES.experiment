% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/experiment2.R
\name{experiment2}
\alias{experiment2}
\alias{experiment2,simList-method}
\title{Run experiment, algorithm 2, using \code{\link[SpaDES.core]{spades}}}
\usage{
experiment2(
  ...,
  replicates = 1,
  clearSimEnv = FALSE,
  createUniquePaths = c("outputPath"),
  useCache = FALSE,
  debug = getOption("spades.debug"),
  drive_auth_account
)

\S4method{experiment2}{simList}(
  ...,
  replicates = 1,
  clearSimEnv = FALSE,
  createUniquePaths = c("outputPath"),
  useCache = FALSE,
  debug = getOption("spades.debug"),
  drive_auth_account = NULL
)
}
\arguments{
\item{...}{One or more \code{simList} objects}

\item{replicates}{The number of replicates to run of the same \code{simList}.
See details and examples. To minimize memory overhead, currently,
this must be length 1, i.e., all \code{...} simList objects will
receive the same number of replicates.}

\item{clearSimEnv}{Logical. If TRUE, then the envir(sim) of each simList in the return list
is emptied. This is to reduce RAM load of large return object.
Default FALSE.}

\item{createUniquePaths}{A character vector of the \code{paths} passed to \code{simInit},
indicating which should create a new, unique path, as a sub-path to the original
\code{paths} of \code{simInit}. Default, and currently only option, is \code{"outputPath"}}

\item{useCache}{Logical. Passed to \code{spades}. This will be passed with the \code{simList}
name and replicate number, allowing each replicate and each \code{simList} to be
seen as a non-cached call to \code{spades}. This will, however, may prevent \code{spades}
calls from running a second time during second call to the same
\code{experiment2} function.}

\item{debug}{Optional tools for invoking debugging. Supplying a \code{list}
will invoke the more powerful \code{logging} package. See details.
Default is to use the value in \code{getOption("spades.debug")}.}

\item{drive_auth_account}{Optional character string. If provided, it will be passed
to each worker and run as \code{googledrive::drive_auth(drive_auth_account)} to allow
a specific user account for googledrive}
}
\value{
Invisibly returns a \code{simLists} object. This class
extends the \code{environment} class and
contains \code{simList} objects.
}
\description{
Given one or more \code{simList} objects, run a series of \code{spades} calls
in a structured, organized way. Methods are available to deal with outputs,
such as \code{as.data.table.simLists} which can pull out simple to complex
values from every resulting \code{simList} or object saved by \code{outputs}
in every \code{simList} run. This uses \code{future} internally, allowing
for various backends and parallelism.0
}
\details{
This function, because of its class formalism, allows for methods to be used. For example,
\code{\link{as.data.table.simLists}} allows user to pull out specific objects (in
the \code{simList} objects or on disk saved in \code{outputPath(sim)}).

The \code{outputPath} is changed so that every simulation puts outputs in a
sub-directory
of the original \code{outputPath} of each \code{simList}.
}
\note{
A \code{simLists} object can be made manually, if, say, many manual \code{spades} calls
have already been run. See example, via \code{new("simLists")}
}
\examples{

\dontrun{
  library(SpaDES.core)
  library(SpaDES.experiment)
  tmpdir <- file.path(tempdir(), "examples")
  # Make 3 simLists -- set up scenarios
  endTime <- 2

  # Example of changing parameter values
  # Make 3 simLists with some differences between them
  mySim <- lapply(c(10, 20, 30), function(nFires) {
    simInit(
      times = list(start = 0.0, end = endTime, timeunit = "year"),
      params = list(
        .globals = list(stackName = "landscape", burnStats = "nPixelsBurned"),
        # Turn off interactive plotting
        fireSpread = list(.plotInitialTime = NA, spreadprob = c(0.2), nFires = c(10)),
        caribouMovement = list(.plotInitialTime = NA),
        randomLandscapes = list(.plotInitialTime = NA, .useCache = "init")
      ),
      modules = list("randomLandscapes", "fireSpread", "caribouMovement"),
      paths = list(modulePath = system.file("sampleModules", package = "SpaDES.core"),
                   outputPath = tmpdir),
      # Save final state of landscape and caribou
      outputs = data.frame(
        objectName = c(rep("landscape", endTime), "caribou", "caribou"),
        saveTimes = c(seq_len(endTime), unique(c(ceiling(endTime / 2), endTime))),
        stringsAsFactors = FALSE
      )
    )
  })

  planTypes <- c("sequential") # try others! ?future::plan
  sims <- experiment2(sim1 = mySim[[1]], sim2 = mySim[[2]], sim3 = mySim[[3]],
                      replicates = 3)

  # Try pulling out values from simulation experiments
  # 2 variables
  df1 <- as.data.table(sims, vals = c("nPixelsBurned", NCaribou = quote(length(caribou$x1))))

  # Now use objects that were saved to disk at different times during spades call
  df1 <- as.data.table(sims,
                       vals = c("nPixelsBurned", NCaribou = quote(length(caribou$x1))),
                       objectsFromOutputs = list(nPixelsBurned = NA, NCaribou = "caribou"))


  # now calculate 4 different values, some from data saved at different times
  # Define new function -- this calculates perimeter to area ratio
  fn <- quote({
    landscape$Fires[landscape$Fires[] == 0] <- NA;
    a <- boundaries(landscape$Fires, type = "inner");
    a[landscape$Fires[] > 0 & a[] == 1] <- landscape$Fires[landscape$Fires[] > 0 & a[] == 1];
    peri <- table(a[]);
    area <- table(landscape$Fires[]);
    keep <- match(names(area),names(peri));
    mean(peri[keep]/area)
  })

  df1 <- as.data.table(sims,
                       vals = c("nPixelsBurned",
                                perimToArea = fn,
                                meanFireSize = quote(mean(table(landscape$Fires[])[-1])),
                                caribouPerHaFire = quote({
                                  NROW(caribou) /
                                    mean(table(landscape$Fires[])[-1])
                                })),
                       objectsFromOutputs = list(NA, c("landscape"), c("landscape"),
                                                 c("landscape", "caribou")),
                       objectsFromSim = "nPixelsBurned")

  if (interactive()) {
    # with an unevaluated string
    library(ggplot2)
    p <- lapply(unique(df1$vals), function(var) {
      ggplot(df1[vals == var,],
             aes(x = saveTime, y = value, group = simList, color = simList)) +
        stat_summary(geom = "point", fun.y = mean) +
        stat_summary(geom = "line", fun.y = mean) +
        stat_summary(geom = "errorbar", fun.data = mean_se, width = 0.2) +
        ylab(var)
    })

    # Arrange all 4 -- could use gridExtra::grid.arrange -- easier
    pushViewport(viewport(layout = grid.layout(2, 2)))
    vplayout <- function(x, y) viewport(layout.pos.row = x, layout.pos.col = y)
    print(p[[1]], vp = vplayout(1, 1))
    print(p[[2]], vp = vplayout(1, 2))
    print(p[[3]], vp = vplayout(2, 1))
    print(p[[4]], vp = vplayout(2, 2))
  }
}
}
\seealso{
\code{\link{as.data.table.simLists}},
  \code{\link{simInit}}, \code{\link[SpaDES.core]{spades}}, \code{\link{experiment}}
}
\author{
Eliot McIntire
}
